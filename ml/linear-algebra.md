##### 向量叉积
```python
c=a×b
c是一个向量,垂直于a、b,方向遵守右手定则
|c|=|a|*|b|*sinθ,几何意义是等于以a和b为邻边的平行四边形的面积
坐标运算
a×b=|i,j,k;ax,ay,az;bx,by,bz|
四则运算
a×b= -b×a
a×(b+c) =a×b+a×c
(ra)×b=a×(rb) = r(a×b)
拉格朗日公式: a×(b×c)=b(a·c)-c(a·b)
平行六面体体积S=(a×b)c,正好是这三个点坐标组成的行列式
```

---
##### 向量点积
```python
c=a·b
c是一个标量,大小等于ax*bx+ay*by+az*bz,也等于|a|*|b|*cosθ
```

---
##### 线性方程组
```python
设(L1)是m*n线性方程组,A是其系数矩阵,(A,p)是其增广矩阵
方程组无解       <=> r(A)<r(A,p)
方程组有唯一解    <=> r(A)=r(A,p)=n
方程组有无穷多个解 <=> r(A)=r(A,p)<n
齐次线性方程组一定有解(如全0解)
设非齐次线性方程组L有解
则L通解=L特解+L对应齐次线性方程组解基的线性组合
r=m=n,L有唯一解
r=n<m,L有唯一解或者无解(应为0空间只有0向量)
r=m<n,L有无穷解
r<m & r<n,L有无穷解或者无解
n个n元线性方程组解唯一          <=> 系数行列式不等于0 
n个n元线性方程组无解or无穷多个解 <=> 系数行列式等于0 
```

---
##### 奇排列 & 偶排列
```python
逆序数是偶数的排列叫偶排列,逆序数是奇数的排列叫奇排列
对换改变排列的奇偶性(证明先考虑ij相邻,再考虑ij相隔)
任意一个n元排列与1,2,...n可以经过一系列对换互变,且对换次数与n元排列有相同的奇偶性
```

---
##### n阶行列式|A|
```python
共有n!项代数和,其中每一项来自于不同行不同列的n个元素的乘积
每一项行指标按自然顺序排列,当列指标排列是偶排列,符号为正,列指标排列是奇排列,符号为负(实质是行列指标的逆序数之和)
上三角形行列式值等于主对角线n个元素的乘积
行列式值等于它的第i行/列每个元素与他们的余子式的代数和,符号等于(-1)^(i+j),利用第i行/列展开可证,可以推广至多行/列的Laplace定理
行列式i行/列每个元素与k(i!=k)行/列的代数余子式之和等于0(利用第k行展开可构造一个i,k行元素相同的行列式)
* |A.T|=|A|
* A的某一行/列乘以常数k得到B =>  |B|=k|A|
* A的某一行/列是两组数的和，则这两组数拆开形成的两个新行列式B,C满足|A|=|B|+|C|
* A的某一行/列的k倍加到另一行/列上,行列式大小不变
* A的任意两行/列互换,行列式的值变为原来的相反数
```

---
##### 矩阵乘
```python
2x+3y+z=1
x+2y+2z=2
矩阵表示: 
[2,3,1;1,2,2][x,y,z].T=[1,2].T
x[2,1].T+y[3,2].T+z[1,2].T=[1,2].T
五种矩阵乘法规则: 
行向量乘列向量 => 对应一个点
列向量乘行向量 => 对应一个矩阵
矩阵乘列向量   => 相当于所有列向量的一个线性组合,列向量可以推广至矩阵
行向量乘矩阵
分块乘        => A的列划分与B的行划分一致
对角阵乘法
[3,0,0;0,4,0;0,0,5]*[1,2;3,4;5,6]=[3*1,3*2;4*3,4*4;5*5,5*6]
```

---
##### 矩阵一般性质
```python
可逆 <=> 可以表示成一系列初等矩阵的乘积
矩阵乘法不满足交换律,满足结合律,分配律
(ABC).T=C.TB.TA.T
|AB|=|A|*|B|
rank(AB)≤min{rank(A),rank(B)}
Hermitian矩阵(A=A.H)对角线元素都是实数,特征值也都是实数,特征向量相互垂直
```

---
##### 矩阵初等变换
```python
1. 交换矩阵的两行/列
2. 以一个非零数k乘矩阵的某一行/列
3. 把矩阵的某一行/列的z倍加于另一行/列上
由单位矩阵经过一次矩阵初等变换得到的矩阵叫做初等矩阵,初等矩阵的逆矩阵仍然是初等矩阵
矩阵初等行变换等价于左乘对应的初等行矩阵,矩阵初等列变换等价于右乘对应的初等列矩阵(利用矩阵乘列向量展开法则可证)
初等变换不会改变方阵A行列式的非零性,所以如果一个矩阵是方阵,我们可以通过看初等变换后的矩阵是否可逆,来判断原矩阵是否可逆
应用:
求矩阵的秩,求向量组的极大无关组,求解线性方程组,求多项式的最大公因式等
```

---
##### 四个基本子空间
```python
设有一个m×n阶矩阵A
rank[C(A)]=rank[C(A.T)]=r
rank[N(A)]=n-r
rank[N(A.T)]=m-r
C(A)和N(A.T)属于R^m且两子空间正交补(按矩阵对应行乘对应列乘法规则即可证明)
C(A.T)和N(A)属于R^n且两子空间正交补
```

---
##### 特征值 & 特征向量
```python
不同特征值的代数重数之和恰为n
不同特征值对应的特征向量线性无关(可由Vandermonde行列式证明),同一特征值的特征向量当然也线性无关
特征值代数重数>=几何重数,如果他们相等,则此时的特征值称为半单的,否则称为亏损
如果某一特征值代数重数为1,则他的几何重数也是1(每个特征值至少有一个特征向量)
特征值之和等于矩阵的迹,特征值之积等于矩阵的行列式
```

---
##### 逆矩阵
```python
设A是数域上的一个n阶方阵,若在相同数域上存在另一个n阶矩阵B,使得AB=BA=E,则称B是A的逆矩阵
A可逆 <=> 满秩方阵 <=> |A|!=0
A的逆矩阵B唯一
可逆矩阵的乘积依然可逆
(A.-1).-1=A
(A.T).-1=(A.-1).T 
(AB).-1=B.-1A.-1
[A,B]   → [I,A.-1B]   （初等行变换）
[A,B].T → [I,BA.-1].T （初等列变换）
[A,I]   → [I,A.-1]    （初等行变换,注意推导过程）
[A,I].T → [I,A.-1].T  （初等列变换）
A.-1= A.*/|A|          (可由行列式的Laplace定理推导出伴随矩阵A*)
|A.*|=|A|^(n-1)
```

---
##### 分块矩阵
```python
分块矩阵的转秩等于每个块先转秩,然后每个块内部再转秩
分块对角阵的逆等于对每个对角块求逆,分块对角阵的转秩等于对每个对角块求转秩,分块对角阵的和等于对应对角块求和,分块对角阵相乘等于对应对角块相乘
```

---
##### 三角矩阵
```python
两个n阶下(上)三角矩阵A与B的乘积仍为下(上)三角矩阵,其AB的主对角元等于A与B的相应住对角元的乘积
可逆下三角矩阵的逆也是下三角阵,若原矩阵对角元素都是1,则逆的对角元也都是1
三角矩阵的特征值就是其对角元素
```

---
##### 投影矩阵
```python
已知b,a1,a2是不共线向量:
A=[a1,a2]; e=b-Ax; A.T(b-Ax)=0 (e垂直于A,则e一定在A的正交补子空间中即A.Te=0)
=> 
b投影向量B=Ax=A(A.TA).-1(A.Tb),其中P=A(A.TA).-1A.T称为投影矩阵,且P.T=P; P^2=P
投影矩阵特征值只能是0和1(数形结合思考,或者将P和P^2正交对角化)
如果矩阵A是满置方阵,则其投影矩阵P是单位阵
A正交补的空间投影矩阵是I-P（b=Pb+(I-P)b）
注意: A必须是列满秩矩阵,才能保证A.TA可逆,否则需要换成与A列向量等价的最大线性无关向量组,或者直接AA.+求投影矩阵
当A的各列是线性无关的单位正交向量时,投影阵P=QQ.T=aa.T+bb.T+...,即施密特正交法核心思想
特别地: 当A只由一个向量a组成时,b投影向量B=(aa.T/a.Ta)b=(a.Tb/a.Ta)a  提示: (AB)C=A(BC); kAB=AkB
B=(a.Tb/a.Ta)a可以看作B关于a的一个线性组合
B=(aa.T/a.Ta)b可以看作A只由一个向量组成的特殊投影
```

---
##### 正交矩阵
```python
若QQ.T=Q.TQ=I,则n阶实矩阵Q称为正交矩阵
1. Q.T是正交矩阵
2. Q的各行是单位向量且两两正交
3. Q的各列是单位向量且两两正交
4. (Qx,Qy)=(x,y) x,y∈R   #内积运算
5. |Q| = 1或-1
6. 几何意义是使向量旋转,不改变向量长度,因此特征值绝对值等于1
方阵Q正交的充要条件是Q的行/列向量组是单位正交向量组
正交方阵是欧氏空间中标准正交基到标准正交基的过渡矩阵
```

---
##### 施密特(Gram-Schmidt)正交法
```python
将线性无关向量组a,b,c化为等价的正交向量组
A=a
B=b-(A.Tb/A.TA)A                # b减去其在A上的分量
C=c-(A.Tc/A.TA)A-(B.Tc/B.TB)B   # c减去其在A,B上的分量,前提是A,B必须保证已正交
C=c- T(T.TT ).-1T.Tc            # 其中T=(a,b)或者T=(A,B)均可,即不要求a,b正交

a=np.array([[1],[-1],[1],[-1]])
b=np.array([[-1],[0],[1],[0]])
c=np.array([1,0,0,0]).reshape(4,1)     # 与上面写法等价
A=np.hstack((a,b))
print(c-A@np.linalg.inv(A.T@A)@A.T@c)  # 不需要保证a,b正交,比如将b换成[-1,0,1,1]即可验证
#施密特正交法,必须保证a,b已正交
print(c-(a@a.T)/(a.T@a)@c-(b@b.T)/(b.T@b)@c)
print(c-(a.T@c)/(a.T@a)*a-(b.T@c)/(b.T@b)*b)
OUTPUT: [.25,.25,.25,.25].T
```
